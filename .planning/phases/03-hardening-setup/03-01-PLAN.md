---
phase: 03-hardening-setup
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/redact.ts
  - src/lib/sanitize.ts
  - src/routes/notify.ts
autonomous: true

must_haves:
  truths:
    - "Terminal output containing AWS keys, JWT tokens, API keys, secrets, and passwords is redacted before SMS"
    - "Redaction happens AFTER ANSI stripping but BEFORE truncation (no partial secret leaks)"
    - "Legitimate terminal output (git SHAs, base64 content) is NOT falsely redacted"
  artifacts:
    - path: "src/lib/redact.ts"
      provides: "Sensitive data detection and redaction function"
      exports: ["redactSensitiveData", "REDACTION_PATTERNS"]
    - path: "src/lib/sanitize.ts"
      provides: "Updated SMS formatting pipeline with redaction step"
      contains: "redactSensitiveData"
  key_links:
    - from: "src/lib/sanitize.ts"
      to: "src/lib/redact.ts"
      via: "import redactSensitiveData"
      pattern: "import.*redactSensitiveData.*from.*redact"
    - from: "src/lib/sanitize.ts"
      to: "redactSensitiveData call"
      via: "called between stripAnsiCodes and non-ASCII removal"
      pattern: "redactSensitiveData\\(cleaned\\)"
---

<objective>
Implement sensitive data redaction for terminal output before SMS transmission (SEC-03).

Purpose: Prevent API keys, tokens, passwords, and other secrets from leaking through SMS messages when terminal output contains sensitive data. This is a security-critical feature that must be correct -- TDD ensures the redaction patterns are thoroughly tested before integration.

Output: Working `redactSensitiveData()` function with comprehensive test coverage, integrated into the `formatForSMS` pipeline in `sanitize.ts`.
</objective>

<execution_context>
@/Users/tylermeans/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylermeans/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-hardening-setup/03-RESEARCH.md
@src/lib/sanitize.ts
@src/routes/notify.ts
</context>

<feature>
  <name>Sensitive Data Redaction</name>
  <files>src/lib/redact.ts, src/lib/redact.test.ts, src/lib/sanitize.ts</files>
  <behavior>
    Redacts sensitive data from text using pattern matching. Patterns sourced from Secrets Patterns DB (well-tested, avoids ReDoS).

    Cases (input -> expected output):
    - "key is AKIA1234567890ABCDEF" -> "key is [REDACTED_AWS_KEY]"
    - 'api_key="abc123def456ghi789jkl012mno345pq"' -> "[REDACTED_API_KEY]"
    - "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.abc123def456" -> "[REDACTED_JWT]"
    - 'secret="abc123def456ghi789jkl012mno345pq"' -> "[REDACTED_SECRET]"
    - 'password="mySuper$ecretP@ss"' -> "[REDACTED_PASSWORD]"
    - "ghp_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef12" -> "[REDACTED_GITHUB_TOKEN]"
    - "sk-abc123def456ghi789jkl012mno345pqrst789012uvwxyz" -> "[REDACTED_OPENAI_KEY]"
    - "normal terminal output" -> "normal terminal output" (no false positive)
    - "git commit abc123def4" -> "git commit abc123def4" (no false positive on short hex)
    - Multiple secrets in one string -> all redacted independently
    - Empty string -> empty string
    - String with no secrets -> unchanged
  </behavior>
  <implementation>
    Create src/lib/redact.ts with:

    1. Export a `RedactionPattern` interface: `{ name: string; pattern: RegExp; replacement: string }`

    2. Export `REDACTION_PATTERNS` array with these specific patterns (from Secrets Patterns DB, validated against ReDoS):
       - AWS Access Key ID: `/AKIA[0-9A-Z]{16}/g` -> `[REDACTED_AWS_KEY]`
       - GitHub Personal Access Token: `/ghp_[a-zA-Z0-9]{36}/g` -> `[REDACTED_GITHUB_TOKEN]`
       - GitHub OAuth Token: `/gho_[a-zA-Z0-9]{36}/g` -> `[REDACTED_GITHUB_TOKEN]`
       - GitHub Fine-Grained Token: `/github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59}/g` -> `[REDACTED_GITHUB_TOKEN]`
       - OpenAI API Key: `/sk-[a-zA-Z0-9]{20}T3BlbkFJ[a-zA-Z0-9]{20}/g` -> `[REDACTED_OPENAI_KEY]`
       - OpenAI Project Key (broader): `/sk-proj-[a-zA-Z0-9_-]{40,}/g` -> `[REDACTED_OPENAI_KEY]`
       - Generic sk- Key (catch-all for Anthropic, Stripe, etc.): `/sk-[a-zA-Z0-9]{32,}/g` -> `[REDACTED_API_KEY]`
       - JWT Token: `/eyJ[a-zA-Z0-9_-]{10,}\.eyJ[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}/g` -> `[REDACTED_JWT]`
       - Generic API Key assignment: `/(?:api[_-]?key|apikey)\s*[:=]\s*['"][a-zA-Z0-9]{20,}['"]/gi` -> `[REDACTED_API_KEY]`
       - Generic Secret assignment: `/(?:secret|secret[_-]?key)\s*[:=]\s*['"][a-zA-Z0-9]{20,}['"]/gi` -> `[REDACTED_SECRET]`
       - Generic Password assignment: `/(?:password|passwd|pwd)\s*[:=]\s*['"][^\s'"]{8,}['"]/gi` -> `[REDACTED_PASSWORD]`
       - Generic Token assignment: `/(?:token|auth[_-]?token|access[_-]?token)\s*[:=]\s*['"][a-zA-Z0-9_-]{20,}['"]/gi` -> `[REDACTED_TOKEN]`
       - Private Key Block: `/-----BEGIN (?:RSA |EC |DSA )?PRIVATE KEY-----[\s\S]*?-----END (?:RSA |EC |DSA )?PRIVATE KEY-----/g` -> `[REDACTED_PRIVATE_KEY]`

    3. Export `redactSensitiveData(text: string): string` that iterates patterns and replaces matches.

    4. Update `formatForSMS` in sanitize.ts to call `redactSensitiveData` between ANSI stripping and non-ASCII removal. The pipeline becomes:
       - Step 1: Strip ANSI codes (existing)
       - Step 2: Redact sensitive data (NEW -- import from redact.ts)
       - Step 3: Remove non-ASCII characters (existing)
       - Step 4: Trim whitespace (existing)
       - Step 5: Truncate if needed (existing)

    IMPORTANT: Order matters per research pitfall 1 -- redaction MUST happen before truncation to prevent partial secret leaks. Redaction SHOULD happen after ANSI stripping so patterns match clean text.

    NOTE: Use `g` flag on all patterns to handle multiple occurrences. For patterns using alternation in character classes, use `[aA]` not `[a|A]` (the pipe is literal inside character classes, per research code review -- fix the research examples).
  </implementation>
</feature>

<verification>
1. `npx tsx src/lib/redact.test.ts` (or equivalent test runner) -- all test cases pass
2. `npx tsc --noEmit` -- no TypeScript errors
3. Grep for `redactSensitiveData` in sanitize.ts confirms integration
4. Manual review: redaction step is positioned AFTER stripAnsiCodes, BEFORE non-ASCII removal
</verification>

<success_criteria>
- redactSensitiveData() correctly redacts all tested secret formats
- No false positives on normal terminal output (git SHAs, file paths, standard text)
- formatForSMS pipeline includes redaction in correct position
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-hardening-setup/03-01-SUMMARY.md`
</output>
