---
phase: 01-core-server-twilio-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/tmux.ts
  - src/lib/sanitize.ts
autonomous: true

must_haves:
  truths:
    - "tmux service can capture last 8 lines from a tmux pane without errors"
    - "Captured terminal output has ANSI escape codes stripped"
    - "tmux service can send keys to a tmux session using literal flag"
    - "User input containing shell metacharacters is sent literally (not executed)"
    - "Invalid session names are rejected before executing tmux commands"
  artifacts:
    - path: "src/services/tmux.ts"
      provides: "Tmux operations: capture context, send keys, has session"
      exports: ["TmuxService"]
      min_lines: 60
    - path: "src/lib/sanitize.ts"
      provides: "ANSI code stripping and text cleanup"
      exports: ["stripAnsiCodes", "formatForSMS"]
  key_links:
    - from: "src/services/tmux.ts"
      to: "child_process.execFile"
      via: "execFile with args array (NEVER exec)"
      pattern: "execFile"
    - from: "src/services/tmux.ts"
      to: "tmux send-keys -l flag"
      via: "literal flag for user input"
      pattern: "send-keys.*-l"
    - from: "src/lib/sanitize.ts"
      to: "strip-ansi package"
      via: "import"
      pattern: "import.*strip-ansi"
---

<objective>
Implement safe tmux integration service for capturing terminal context and sending user responses back to Claude Code sessions.

Purpose: Enable bidirectional communication with tmux sessions â€” capture terminal output for SMS context and send user replies without command injection vulnerabilities. Security is built in from day one using execFile with args arrays and literal flag for all user input.

Output: Working tmux service that safely captures pane output, strips ANSI codes, validates session names, and sends user input literally.
</objective>

<execution_context>
@/Users/tylermeans/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tylermeans/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/tylermeans/github/claude-sms-connect/.planning/PROJECT.md
@/Users/tylermeans/github/claude-sms-connect/.planning/ROADMAP.md
@/Users/tylermeans/github/claude-sms-connect/.planning/phases/01-core-server-twilio-integration/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create sanitize library for terminal output cleanup</name>
  <files>
src/lib/sanitize.ts
  </files>
  <action>
Create text sanitization utilities for cleaning terminal output before SMS transmission:

1. Import strip-ansi package

2. Export stripAnsiCodes(text: string): string
   - Use strip-ansi to remove all ANSI escape sequences
   - Return cleaned text

3. Export formatForSMS(text: string, maxChars: number = 450): string
   - Strip ANSI codes using stripAnsiCodes
   - Remove non-ASCII characters (forces GSM-7 encoding for cheaper SMS): text.replace(/[^\x00-\x7F]/g, '')
   - Trim whitespace
   - Truncate to maxChars with "..." if needed
   - Return formatted text

Why 450 chars: Keeps SMS under 3 segments (160 chars each for GSM-7 encoding), per research recommendation to control costs.

4. Add JSDoc comments documenting:
   - Why non-ASCII removal (SMS cost management)
   - Why 450 char limit (3 segment maximum)
   - Security note: This is NOT for sensitive data filtering (Phase 3), just encoding optimization
  </action>
  <verify>
Create a test script or use tsx to verify:
1. stripAnsiCodes removes ANSI codes: `stripAnsiCodes('\x1b[31mRed text\x1b[0m')` returns "Red text"
2. formatForSMS removes Unicode: `formatForSMS('Hello ðŸ‘‹ world')` returns "Hello  world"
3. formatForSMS truncates long text: `formatForSMS('a'.repeat(500))` returns 450 chars + "..."
  </verify>
  <done>
stripAnsiCodes removes all ANSI escape sequences, formatForSMS strips non-ASCII and truncates to 450 chars, functions are exported and ready for use by tmux and twilio services.
  </done>
</task>

<task type="auto">
  <name>Create tmux service with safe command execution</name>
  <files>
src/services/tmux.ts
  </files>
  <action>
Create tmux integration service following security patterns from research (SEC-04, SEC-05):

1. Import required modules:
   - child_process: execFile (NOT exec â€” security requirement)
   - util: promisify

2. Create promisified execFile: `const execFileAsync = promisify(execFile)`

3. Export TmuxService class with methods:

   a) validateSessionName(session: string): void
      - Test against regex: /^[a-zA-Z0-9_-]+$/
      - Throw error if invalid (prevents command injection)
      - Log validation failures

   b) async hasSession(session: string): Promise<boolean>
      - Validate session name first
      - Execute: execFileAsync('tmux', ['has-session', '-t', session])
      - Return true if succeeds, false if throws (session doesn't exist)
      - Catch and handle errors gracefully

   c) async captureContext(session: string, lines: number = 8): Promise<string>
      - Validate session name first
      - Check session exists with hasSession (throw if not)
      - Execute: execFileAsync('tmux', ['capture-pane', '-t', session, '-p', '-S', `-${lines}`])
      - Return stdout (raw terminal output with ANSI codes)
      - Let caller handle sanitization (separation of concerns)

   d) async sendKeys(session: string, input: string): Promise<void>
      - Validate session name first
      - Check session exists with hasSession (throw if not)
      - Execute TWO separate execFile calls:
        1. Send input with literal flag: execFileAsync('tmux', ['send-keys', '-t', session, '-l', input])
        2. Send Enter key: execFileAsync('tmux', ['send-keys', '-t', session, 'Enter'])
      - CRITICAL: Use '-l' flag for user input (literal mode prevents tmux key binding interpretation)
      - Never combine input + Enter in single command (security requirement)

4. Add comprehensive JSDoc comments on sendKeys method explaining:
   - Why -l flag is required (security: prevents command injection via tmux key names)
   - Why two separate commands (Enter must not be literal)
   - Why execFile + args array (security: prevents shell injection)

5. Export singleton instance: `export const tmuxService = new TmuxService()`

SECURITY REQUIREMENTS (from research):
- NEVER use child_process.exec() â€” always execFile()
- NEVER use string interpolation for tmux commands
- ALWAYS use args array for execFile
- ALWAYS use -l flag for send-keys with user input
- ALWAYS validate session names before executing commands
  </action>
  <verify>
Create verification tests (can be manual with active tmux session):

1. Start a test tmux session: `tmux new -d -s test-session`
2. Test captureContext:
   - Send some text to session: `tmux send-keys -t test-session -l "Hello from test"`
   - Call captureContext('test-session', 5)
   - Verify output contains "Hello from test"
3. Test sendKeys with normal input:
   - Call sendKeys('test-session', 'echo test')
   - Verify command appears in session output
4. Test sendKeys with dangerous input (CRITICAL security test):
   - Call sendKeys('test-session', '$(whoami)' )
   - Verify literal string "$(whoami)" appears, NOT the result of whoami command
   - Call sendKeys('test-session', '; rm -rf /')
   - Verify literal string appears, NOT executed
5. Test invalid session name rejection:
   - Call sendKeys('invalid;session', 'test') should throw error
6. Clean up: `tmux kill-session -t test-session`
  </verify>
  <done>
TmuxService class exports captureContext, sendKeys, and hasSession methods. All tmux commands use execFile with args arrays. sendKeys uses -l literal flag for user input. Session names are validated before execution. Dangerous input (shell metacharacters) is sent literally, not executed.
  </done>
</task>

</tasks>

<verification>
1. All files exist with expected exports
2. stripAnsiCodes removes ANSI escape sequences
3. formatForSMS limits output to 450 chars and removes non-ASCII
4. tmuxService.captureContext retrieves terminal output from active session
5. tmuxService.sendKeys sends user input literally (shell metacharacters not executed)
6. Invalid session names throw errors before executing tmux commands
</verification>

<success_criteria>
- Tmux service can capture terminal context from running sessions
- ANSI codes are stripped from terminal output
- User input is sent to tmux sessions using literal flag (command injection prevented)
- Session name validation prevents malformed tmux commands
- All tmux operations use execFile with args arrays (no shell interpolation)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-server-twilio-integration/01-02-SUMMARY.md`
</output>
